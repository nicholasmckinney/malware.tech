+++
title = "Statically Unpacking Shellcode-based PE Loaders"
date = "2022-10-29T00:00:00Z"
categories = ["shellcode", "malware"]
tags = ["shellcode", "malware"]
+++

{{< toc >}}

## A Quick History Lesson on Relevant Loader Techniques

The ability to run arbitrary executables and scripts in local or remote process memory is an appealing feature for many malware. Malware frameworks possessing this functionality are much more flexible with it, as operators can integrate new tools (in many cases written by completely different developers) without requiring more development on the core malware framework. This also makes features like Metasploit's `migrate` trivial to implement for many C2 frameworks.

<br>

Prior to the release of Monoxgas's sRDI and TheWover's Donut, loaders typically required code to manually map a PE file in memory or else utilize Reflective DLL Injection.

<br>

The primary issue with the former technique is the amount of effort that must go into the development of that mapping process, requiring more knowledge of the PE file format and its intricacies and edge-cases (TLS callbacks and SEH being a couple). Because the development work required is time-consuming, loader code developed for an unmanaged executable (e.g. C/C++) will in many cases lack the support for running managed (C# .NET) PE files.

<br>

Reflective DLL Injection was popularized due to the ability to run arbitrary DLLs in remote process memory without the need to drop any files to disk or force the call to LoadLibrary in the target process after its initialization (where most of the calls to LoadLibrary would be expected). Malware authors often copied the original implementation by Stephen Fewer for use in their tools. However, a downside to this approach was that the target DLL to be injected had to be integrated with the reflective loading stub at the time of development, so injecting arbitrary DLLs for execution was non-trivial.

<br>

Monoxgas's sRDI (shellcode Reflective DLL Injection) wraps arbitrary DLLs with a reflective loading stub to allow for the easy conversion to shellcode. With this approach, a malware framework need only inject the shellcode generated by sRDI into a remote process and set a thread to execute it. This is much simpler to implement from the perspective of the malware framework developer.

<br>

With the release of Donut, TheWover took the technique from sRDI and went a few steps further, allowing the conversion of managed and unmanaged PE files (.NET or native, respectively) and even scripts written in VBScript and JScript to shellcode. At this point in time, defensive techniques for Powershell-based malware (popularized by the likes of Powershell Empire) were becoming more mature, causing a migration to other languages. Tools written in .NET became more popular due to ease of development when compared to C/C++, but were commonly run via Cobalt Strike (a native tool). The issue was that the `execute-assembly` command in CS was limited to running the .NET tools in sacrificial child processes and could not be extended to running them in arbitrary remote processes. Donut allowed the conversion of all these different file formats to shellcode that could be run locally or remotely, as it took care of the instantiation and lifecycle of any necessary runtimes. This means that processes birthed from programs written in unmanaged languages (C/C++, Golang, etc.) could run Donut-generated shellcode constructed from managed (.NET) PE files by simply allocating the memory, writing the shellcode to it, and triggering a thread to execute it.

<br>


## Payload Extraction with Nutex

Ultimately, all of the shellcode-loader tools generate files that might be extracted from an analyzed malware's embedded resources, or from memory. The embedded payload may be found mapped in memory, but with [Nutex](https://github.com/nicholasmckinney/nutex), we can determine how it was generated:

* The specific loader

* Export called (if DLL)

* Program Arguments



If the unpacked target memory was simply dumped to disk, these would not be seen.

Nutex targets 3 publicly-available, popular shellcode loaders:

* TheWover's [Donut](https://github.com/TheWover/donut)

* Monoxgas's [sRDI](https://github.com/monoxgas/sRDI)

* Hasherezade's [pe2shc](https://github.com/hasherezade/pe_to_shellcode)


In order to extract the payload, each had to be analyzed in order to determine the necessary steps. We'll start from the simplest to the most complex.


### pe2shc


Amongst the three tools targeted, Hasherezade's [pe2shc](https://github.com/hasherezade/pe_to_shellcode) was the simplest to approach.  

<br>

![PE2SHC visual](/images/posts/unpacking-shellcode-loaders/pe2shc_generated_file.png)


<br>

This is because Hasherezade's tool does not actually functionally modify the input PE file in such a way that it can't be used normally. Portable Executable files contain header fields that can be used to calculate its raw size on disk, so appending data after that calculated offset will not affect normal function. 

<br>

![PE Headers](/images/posts/unpacking-shellcode-loaders/PE101.png)

<br>

The beginning of any PE file (EXE, DLL, etc.) contains a magic number (represented in ASCII as MZ) that the operating system will use in part to identify the file as having the PE format. After those two bytes, there are several null bytes that aren't utilized. pe2shc simply repurposes this space to write an initial stub that will redirect code execution to the main stub written after the PE file.

<br>
![Repurposed bytes](/images/posts/unpacking-shellcode-loaders/pe_header_space.png)

<br>

Redirection shellcode stub:
<br>

![Redir code](/images/posts/unpacking-shellcode-loaders/pe2shc_redir_header.png)

<br>

The main stub will perform the actual loading steps to execute the payload. By doing this, an operator of the tool does not need to set the thread to execute at the offset of the main loader stub, which will be at different addresses for differently-sized PE files. Instead, they can simply set the execution to occur at the starting address of the allocated memory. This redirection loader is specific to the architecture of the input file, with [support for both x86 and AMD64 provided](https://github.com/hasherezade/pe_to_shellcode/blob/master/pe2shc/main.cpp#L28-L50).

<br>

This can be seen in the [`shellcodify`](https://github.com/hasherezade/pe_to_shellcode/blob/master/pe2shc/main.cpp#L72-L95) function.

<br>

![pe2shc shellcodify](/images/posts/unpacking-shellcode-loaders/pe2shc_shellcodify.png)

<br>

pe2shc will perform the following steps:

<br>

1) Write input PE file to buffer

2) Write main shellcode loader after PE file

3) Overwrite beginning bytes of PE file with the redirection stub that will redirect execution to (2)

<br>

#### Detection

<br>

Utilizing the latest code from Detect-It-Easy, we can see that it detects out of the box usage of pe2shc. Because pe2shc does not functionally modify the usage of the PE file, DIE can also detect and parse the input payload (in this case, Internet Explorer).

<br>
![DIE pe2shc](/images/posts/unpacking-shellcode-loaders/die_detect_pe2shc.png)

<br>

#### Unpacking

The extra data of the two stubs will not affect the usage of a given PE file modified by pe2shc. As a result, double-clicking or running via the CMD prompt one of the generated files will give the same result as if the input file had not been modified. `No unpacking steps are necessary.`

<br>

### Monoxgas's sRDI

<br>

![sRDI Generated](/images/posts/unpacking-shellcode-loaders/srdi_generated_file.png)

<br>

Monoxgas's sRDI takes a slightly different approach than Hasherezade's pe2shc. Firstly, sRDI only takes DLLs as input. It works as an alternative to Reflective DLL Injection, allowing the ability to load arbitrary DLLs, but not regular EXEs. 

<br>

sRDI supports the ability to specify an export of the DLL to call, as well as optional arguments to pass to that function. Unlike pe2shc, the generated file is not a valid PE file any longer. Like pe2shc, however, two shellcode stubs exist. In sRDI, these stubs are adjacent, starting at the beginning of the file with the bootstrap followed by the RDI loader. The author provides a comment describing this.

<br>
![sRDI File Layout](/images/posts/unpacking-shellcode-loaders/srdi_layout.png)

<br>
The purpose of the bootstrap shellcode is to inform the reflective loader stub of the function to call, any arguments to pass to that function, and any additional flags used to toggle obfuscation features. The reflective loader stub is static, and doesn't change much beyond whatever small differences compiler versions might create inadvertently. 

<br>

To hide the exported function called in the input DLL, the name is [hashed with ROT13](https://github.com/monoxgas/sRDI/blob/master/Python/ShellcodeRDI.py#L48-L53). The value is [stored in the bootstrap shellcode](https://github.com/monoxgas/sRDI/blob/master/Python/ShellcodeRDI.py#L82-L84). The code in the `if` case above the `else` statement [appears to be unused](https://github.com/monoxgas/sRDI/blob/master/Python/ConvertToShellcode.py#L36).

<br>
![sRDI ROT13 hashing function name](/images/posts/unpacking-shellcode-loaders/srdi_rot13.png)

<br>
The location of the user data will be calculated, packed into the shellcode as a 4-byte integer before its length. The location of the user data is used as a pointer and stored in the [AMD64 `r8` register. The length of the user data is stored in `r9`.](https://github.com/monoxgas/sRDI/blob/master/Python/ShellcodeRDI.py#L86-L94) (the `d` in `rd9` just specifies we want to store the value of the user data as the lower 32-bits in the register. In AMD64, the calling convention uses these registers as the 3rd and 4th arguments passed to a function. As a result, they will be passed to the `lpUserData` and `dwUserdataLen` parameters in [ShellcodeRDI/ShellcodeRDI.c](https://github.com/monoxgas/sRDI/blob/master/ShellcodeRDI/ShellcodeRDI.c#L118).

<br>
![sRDI func](/images/posts/unpacking-shellcode-loaders/srdi_rdi_func.png)

<br>

In a similar way, the flags are [packed and stored in the bootstrap shellcode](https://github.com/monoxgas/sRDI/blob/master/Python/ShellcodeRDI.py#L117-L120) such that when the shellcode runs, they will be pushed on the stack to be used by the function shown above. These flags [enable minor obfuscation techniques](https://github.com/monoxgas/sRDI/blob/master/Python/ConvertToShellcode.py#L27-L34) such as clearing the PE header of the loaded DLL to make its file format harder to analyze in memory. Other flags increase the amount of time before each import required by the RDI loader stub is imported, as a measure to try to bypass runtime detections. Finally, the base address of the bootstrap shellcode could be passed to DLL function called.

<br>
![sRDI flags](/images/posts/unpacking-shellcode-loaders/srdi_flags.png)

<br>

In essence, you can think of the sRDI output (as well as Donut) shellcode as a really funky file format. By using known offsets, we can unpack files that used sRDI out-of-the-box.

<br>
#### Detection

As with pe2shc, I wrote a Detect-It-Easy detection for sRDI.

<br>
![sRDI Detected](/images/posts/unpacking-shellcode-loaders/die_detect_srdi.png)

<br>
Note that this will work with some other implementions of sRDI if the same bootstrap shellcode format is used. I noticed this in some cases with implementations written in other languages like [this](https://github.com/memN0ps/srdi-rs/blob/main/generate_shellcode/src/main.rs). 

<br>
#### Unpacking

<br>
![sRDI payload plaintext](/images/posts/unpacking-shellcode-loaders/srdi_payload_unencrypted.png)

<br>

To get the data we want, we need to extract from the bootstrap shellcode the following values:

* DLL Length

* DLL Offset

* Flags

* User Data Length

* User Data Location

* Target Function Hash

<br>
![sRDI sxs](/images/posts/unpacking-shellcode-loaders/srdi_code_mapping_reading.png)

<br>


An interesting thing to note is that the input DLL and user-data is actually not encrypted in the packed output of sRDI. As a result, a simple script to find a valid PE header and extracting the payload using the relevant structure fields might suffice. With the user data (program arguments) left in plaintext as well, a simple check for the default user data of [dave](https://github.com/monoxgas/sRDI/blob/master/Python/ConvertToShellcode.py#L11) (yes, really) might yield some results in identifying malicious memory. 

<br>

However, these processes would not yield the function called within the DLL. If the DLL contains many exported functions as a form of obfuscation (to hide from the malware analyst which one(s) is used), then simply extracting the payload would not be enough. It was required to reimplement the 32-bit ROT13 implementation in order to perform the same hashing function; this would allow us to test equivalence between what is set by the bootstrap shellcode, and the various results when using DLL function export names as input. As a result of comparing the stored hash value with the hash values produced by running the DLL export names through the function, we can determine the actual target function.

<br>
![sRDI ROT13](/images/posts/unpacking-shellcode-loaders/srdi_rot13_python.png)

<br>
The value of the function shown above is [calculated](https://github.com/monoxgas/sRDI/blob/master/Python/ConvertToShellcode.py#L36) and then passed to the function that builds the bootstrap shellcode. 