+++
title = "Statically Unpacking Shellcode-based PE Loaders with Donut, sRDI, and pe2shc"
date = "2022-10-29T00:00:00Z"
categories = ["shellcode", "malware"]
tags = ["shellcode", "malware"]
+++

{{< toc >}}

## A Quick History Lesson on Relevant Loader Techniques

The ability to run arbitrary executables and scripts in local or remote process memory is an appealing feature for many malware. Malware frameworks possessing this functionality are much more flexible with it, as operators can integrate new tools (in many cases written by completely different developers) without requiring more development on the core malware framework. This also makes features like Metasploit's `migrate` trivial to implement for many C2 frameworks.

<br>

Prior to the release of Monoxgas's sRDI and TheWover's Donut, loaders typically required code to manually map a PE file in memory or else utilize Reflective DLL Injection.

<br>

The primary issue with the former technique is the amount of effort that must go into the development of that mapping process, requiring more knowledge of the PE file format and its intricacies and edge-cases (TLS callbacks and SEH being a couple). Because the development work required is time-consuming, loader code developed for an unmanaged executable (e.g. C/C++) will in many cases lack the support for running managed (C# .NET) PE files.

<br>

Reflective DLL Injection was popularized due to the ability to run arbitrary DLLs in remote process memory without the need to drop any files to disk or force the call to LoadLibrary in the target process after its initialization (where most of the calls to LoadLibrary would be expected). Malware authors often copied the original implementation by Stephen Fewer for use in their tools. However, a downside to this approach was that the target DLL to be injected had to be integrated with the reflective loading stub at the time of development, so injecting arbitrary DLLs for execution was non-trivial.

<br>

Monoxgas's sRDI (shellcode Reflective DLL Injection) wraps arbitrary DLLs with a reflective loading stub to allow for the easy conversion to shellcode. With this approach, a malware framework need only inject the shellcode generated by sRDI into a remote process and set a thread to execute it. This is much simpler to implement from the perspective of the malware framework developer.

<br>

With the release of Donut, TheWover took the technique from sRDI and went a few steps further, allowing the conversion of managed and unmanaged PE files (.NET or native, respectively) and even scripts written in VBScript and JScript to shellcode. At this point in time, defensive techniques for Powershell-based malware (popularized by the likes of Powershell Empire) were becoming more mature, causing a migration to other languages. Tools written in .NET became more popular due to ease of development when compared to C/C++, but were commonly run via Cobalt Strike (a native tool). The issue was that the `execute-assembly` command in CS was limited to running the .NET tools in sacrificial child processes and could not be extended to running them in arbitrary remote processes. Donut allowed the conversion of all these different file formats to shellcode that could be run locally or remotely, as it took care of the instantiation and lifecycle of any necessary runtimes. This means that processes birthed from programs written in unmanaged languages (C/C++, Golang, etc.) could run Donut-generated shellcode constructed from managed (.NET) PE files by simply allocating the memory, writing the shellcode to it, and triggering a thread to execute it.

<br>


## Payload Extraction with Nutex

Ultimately, all of the shellcode-loader tools generate files that might be extracted from an analyzed malware's embedded resources, or from memory. The embedded payload may be found mapped in memory, but with [Nutex](https://github.com/nicholasmckinney/nutex), we can determine how it was generated:

* The specific loader

* Export called (if DLL)

* Program Arguments



If the unpacked target memory was simply dumped to disk, these would not be seen.

Nutex targets 3 publicly-available, popular shellcode loaders:

* TheWover's [Donut](https://github.com/TheWover/donut)

* Monoxgas's [sRDI](https://github.com/monoxgas/sRDI)

* Hasherezade's [pe2shc](https://github.com/hasherezade/pe_to_shellcode)


In order to extract the payload, each had to be analyzed in order to determine the necessary steps. We'll start from the simplest to the most complex.


### pe2shc


Amongst the three tools targeted, Hasherezade's [pe2shc](https://github.com/hasherezade/pe_to_shellcode) was the simplest to approach.  

<br>

![PE2SHC visual](/images/posts/unpacking-shellcode-loaders/pe2shc_generated_file.png)


<br>

This is because Hasherezade's tool does not actually functionally modify the input PE file in such a way that it can't be used normally. Portable Executable files contain header fields that can be used to calculate its raw size on disk, so appending data after that calculated offset will not affect normal function. 

<br>

![PE Headers](/images/posts/unpacking-shellcode-loaders/PE101.png)

<br>

The beginning of any PE file (EXE, DLL, etc.) contains a magic number (represented in ASCII as MZ) that the operating system will use in part to identify the file as having the PE format. After those two bytes, there are several null bytes that aren't utilized. pe2shc simply repurposes this space to write an initial stub that will redirect code execution to the main stub written after the PE file.

<br>
![Repurposed bytes](/images/posts/unpacking-shellcode-loaders/pe_header_space.png)

<br>

The main stub will perform the actual loading steps to execute the payload. By doing this, an operator of the tool does not need to set the thread to execute at the offset of the main loader stub, which will be at different addresses for differently-sized PE files. Instead, they can simply set the execution to occur at the starting address of the allocated memory.

<br>

This can be seen in the [`shellcodify`](https://github.com/hasherezade/pe_to_shellcode/blob/master/pe2shc/main.cpp#L72-L95) function.

<br>

![pe2shc shellcodify](/images/posts/unpacking-shellcode-loaders/pe2shc_shellcodify.png)

<br>

pe2shc will perform the following steps:

<br>

1) Write input PE file to buffer

2) Write main shellcode loader after PE file

3) Overwrite beginning bytes of PE file with the redirection stub that will redirect execution to (2)