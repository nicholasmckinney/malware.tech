+++
title = "Statically Unpacking Shellcode-based PE Loaders with Donut, sRDI, and pe2shc"
date = "2022-10-29T00:00:00Z"
categories = ["shellcode", "malware"]
tags = ["shellcode", "malware"]
+++

{{< toc >}}

## A Quick History Lesson on Relevant Loader Techniques

The ability to run arbitrary executables and scripts in local or remote process memory is an appealing feature for many malware. Malware frameworks possessing this functionality are much more flexible with it, as operators can integrate new tools (in many cases written by completely different developers) without requiring more development on the core malware framework. This also makes features like Metasploit's `migrate` trivial to implement for many C2 frameworks.

Prior to the release of Monoxgas's sRDI and TheWover's Donut, loaders typically required code to manually map a PE file in memory or else utilize Reflective DLL Injection. 

The primary issue with the former technique is the amount of effort that must go into the development of that mapping process, requiring more knowledge of the PE file format and its intricacies and edge-cases (TLS callbacks and SEH being a couple). Because the development work required is time-consuming, loader code developed for an unmanaged executable (e.g. C/C++) will in many cases lack the support for running managed (C# .NET) PE files.

Reflective DLL Injection was popularized due to the ability to run arbitrary DLLs in remote process memory without the need to drop any files to disk or force the call to LoadLibrary in the target process after its initialization (where most of the calls to LoadLibrary would be expected). Malware authors often copied the original implementation by Stephen Fewer for use in their tools. However, a downside to this approach was that the target DLL to be injected had to be integrated with the reflective loading stub at the time of development, so injecting arbitrary DLLs for execution was non-trivial.

Monoxgas's sRDI (shellcode Reflective DLL Injection) wraps arbitrary DLLs with a reflective loading stub to allow for the easy conversion to shellcode. With this approach, a malware framework need only inject the shellcode generated by sRDI into a remote process and set a thread to execute it. This is much simpler to implement from the perspective of the malware framework developer.

With the release of Donut, TheWover took the technique from sRDI and went a few steps further, allowing the conversion of managed and unmanaged PE files (.NET or native, respectively) and even scripts written in VBScript and JScript to shellcode. At this point in time, defensive techniques for Powershell-based malware (popularized by the likes of Powershell Empire) were becoming more mature, causing a migration to other languages. Tools written in .NET became more popular due to ease of development when compared to C/C++, but were commonly run via Cobalt Strike (a native tool). The issue was that the `execute-assembly` command in CS was limited to running the .NET tools in sacrificial child processes and could not be extended to running them in arbitrary remote processes. Donut allowed the conversion of all these different file formats to shellcode that could be run locally or remotely, as it took care of the instantiation and lifecycle of any necessary runtimes. This means that processes birthed from programs written in unmanaged languages (C/C++, Golang, etc.) could run Donut-generated shellcode constructed from managed (.NET) PE files by simply allocating the memory, writing the shellcode to it, and triggering a thread to execute it.


## Payload Extraction with Nutex

Ultimately, all of the shellcode-loader tools generate files that might be extracted from an analyzed malware's embedded resources, or from memory. The embedded payload may be found mapped in memory, but with [Nutex](https://github.com/nicholasmckinney/nutex), we can determine how it was generated:

* The specific loader

* Export called (if DLL)

* Program Arguments



If the unpacked target memory was simply dumped to disk, these would not be seen.

Nutex targets 3 publicly-available, popular shellcode loaders:

* TheWover's [Donut](https://github.com/TheWover/donut)

* Monoxgas's [sRDI](https://github.com/monoxgas/sRDI)

* Hasherezade's [pe2shc](https://github.com/hasherezade/pe_to_shellcode)


In order to extract the payload, each had to be analyzed in order to determine the necessary steps. We'll start from the simplest to the most complex.


### pe2shc


Amongst the three tools targeted, Hasherezade's [pe2shc](https://github.com/hasherezade/pe_to_shellcode) was the simplest to approach.  

<br>

![PE2SHC visual](/images/posts/unpack-shellcode-loaders/pe2shc_generated_file.png)


<br>

