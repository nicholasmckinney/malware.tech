---
title: Using AWS CLI or Terraform with Credentials from Google Workspace SSO
date: 2022-02-26T00:00:00Z
---

![The final product](/images/post/1/028-aws-login.PNG)

## Background

In my current lab environment, I AWS to provide services that would otherwise be difficult for myself to handle (while trying to follow best practices), such as key management and replicated file storage. I use Google Workspace in order to provide a single sign-on experience across applications, whether they support only LDAPS or more modern Auth N&Z flows like OIDC and SAML. 


With such a combination of services, I have my lab configured such that I can log into the Google Workspace user dashboard and assume a preconfigured role for a particular account from a selection page. I do this through setting up a SAML trust relationship with each AWS IAM role that I wish for users of my lab organization to be able to access. Once the role is assumed, the user is able to access the AWS console with the permissions of the role.

Through this method, I can focus on scoping permissions to roles instead of to users. This subtle difference can help prevent permission creep whereby a user may over time become overprivileged. Applying permissions directly to users can create an issue with not knowing what each individual can access. This method of granting authorization prevents that mishap by enabling organizations to easily see the permissions to which a user has been assigned via the roles they can assume.

## The Issue

This setup has worked great, but there is one gaping problem that has not been seriously addressed by AWS for years (and it'll be easy to guess why that is the case).



*That problem is <u>enabling API access (via the CLI or Terraform) through credentials assumed after authenticating to the Google Workspace IdP.</u>* 



## Multiple Sources of Identity: An Anti-Pattern as a Workaround



How do people and organizations work around this?



One anti-pattern that I have seen is long-term utilization of IAM users for engineers or people who otherwise need access to AWS. In doing so, multiple sources of identity are created in their system; at least one for access to SSO via their IdP, and one for AWS via their IAM user. By doing this, they can create api keys that can be used in the configuration of the AWS CLI. While the ease in doing so can be alluring, and even if the organization tends toward the usage of roles via policies applied directly, having multiple sources of identity always becomes problematic in auditing user permissions and granting/removing access.



## Possibilities?



The AWS API supports [assuming a role via a SAML response](https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role-with-saml.html). As previously mentioned, I have integrated Google Workspace with AWS by setting up trust relationships in roles that I wish users to be able to assume. This should, *in theory*, be easy to do.



However, we run into an issue because <u>Google Workspace does not provide a supported solution to getting a SAML response programmatically</u>. Unsupported workarounds do exist such as [aws-google-auth](https://github.com/cevoaustralia/aws-google-auth). Because they are not officially supported by either Google or Amazon, I steered clear of it.  



## Solution



As a result, I solved the problem by utilizing AWS SSO with Google Workspace as an external IdP. It's not a perfect solution (and I'll detail the issues below), but it was the best available. 



You might ask: [what is AWS SSO?](https://aws.amazon.com/blogs/security/how-to-create-and-manage-users-within-aws-sso/)



> [AWS Single Sign-On](https://aws.amazon.com/single-sign-on/) (AWS SSO) is a cloud service that allows you to grant your users access to AWS resources, such as Amazon EC2 instances, across multiple AWS  accounts. By default, AWS SSO now provides a directory that you can use  to create users, organize them in groups, and set permissions across  those groups. You can also grant the users that you create in AWS SSO  permissions to applications such Salesforce, Box, and Office 365. AWS  SSO and its directory are available at no additional cost to you.



Essentially, the service can act as a SAML IdP and provides minimal support for OIDC (integrated only with AWS API and tooling). We can configure it to use an external identity provider, but a user must exist in AWS SSO with a username matching the Name ID attribute passed (\*sigh\*). AWS SSO also doesn't support SCIM (essentially user replication from the external IdP) with Google Workspace (to nobody's surprise). This unfortunately means that every user we want to be able to use AWS programmatically will need a user provisioned for them in AWS SSO. 





Note that **AWS SSO accounts will only work if there is a user with a matching email address as the username in Google Workspace.** Essentially, to use AWS, a user will have to authenticate to Google, which will then sign a message that will be relayed to AWS by the user proving that they are in control of the user with the matching email address. This shouldn't be a cumbersome task as the number of users that will probably need such access should be limited; changes to the system should be relegated almost entirely to CI/CD tooling. However, this is still a very slippery slope to having multiple sources of identity and so is not an ideal solution. [Attribute based access control (ABAC)](https://docs.aws.amazon.com/singlesignon/latest/userguide/attributesforaccesscontrol.html?icmpid=docs_sso_console) is supported in AWS SSO, but permission sets (IAM policies) cannot be applied to users on it alone, and so utilizing AWS SSO groups (another source of identity) is still required, unfortunately.



To make matters a little more annoying, AWS doesn't provide an adequate public API for the SSO service. AWS SSO groups and users cannot be codified, making the utilization of identity-as-code near impossible and so making auditing more difficult. As a result, the [Terraform resources](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ssoadmin_account_assignment) are limited, and doesn't support the codification of users. So much of what we'll do here will be manual. 



### Bill of Materials

In order to build the solution, we'll need to set up several things:

* AWS SSO
  * Create user(s) with username matching their email in Google Workspace
  * Create an SSO group to which they are assigned
  * Assign a *permission set* to the group allowing members to assume specific roles to which they should be authorized.
* Google Workspace
  * Create a SAML application configured to allow AWS SSO as a client



### Steps

First, go to the AWS SSO service page.

![SSO Service](/images/posts/1/001-sso-settings-edited.png)



Next to *Identity source*, click the **Change** button and select the option for the *External identity provider*. Take note of the different URLs listed as they'll be required for the SAML application created next.

![External provider option](/images/posts/1/004-aws-saml-settings-edited.png)



In a new tab, go to your Google Workspace admin dashboard and start creating a new custom SAML application.

![Add a SAML app](/images/posts/1/002-gworkspace-create-custom-saml-app.PNG)

After choosing a name, download the IdP metadata file.

![Download IdP metadata](/images/posts/1/003-gworkspace-download-metadata.PNG)

On the next page, apply the URLs previously retrieved from AWS earlier. 

![Use URLs](/images/posts/1/gworkspace-saml-app-urls.PNG)

| AWS URL             | Google Workspace URL |
| ------------------- | -------------------- |
| AWS SSO ACS URL     | ACS URL              |
| AWS SSO issuer URL  | Entity ID            |
| AWS SSO Sign-in URL | Start URL            |

Set the Name ID options as follows:

![Name ID options](/images/posts/1/005-gworkspace-set-identity.PNG)



After creating the SAML application in Google Workspace, it may be disabled by default for all users. 



![SAML app disabled by default](/images/posts/1/007-gworkspace-app-disabled-by-default.PNG)

You'll need to enable it if that is the case.

![Enabling SAML app access](/images/posts/1/008-gworkspace-enable-app-for-everybody.PNG)

Back in AWS SSO, upload the metadata file downloaded from Google Workspace to configure it to use the SAML application just created.





Next, we'll need to create a group to manage the permissions for our users. I created a group called *Command-Line-Users* as follows.

![Create AWS SSO group](/images/posts/1/009-aws-create-group.PNG)



For each user, you'll have to create a new AWS SSO user.

![Creating SSO user](/images/posts/1/010-aws-create-user-edited.png)

Add each user to the group(s) required:

![Add user to group](/images/posts/1/011-add-user-to-group.PNG)



Next, go to the AWS SSO > AWS Accounts page. Select an account to which you wish to grant access. As odd as it may sound, click the **Assign users** button. Now, select the group you just created.

![Select group](/images/posts/1/013-aws-assign-group-to-account.PNG)

Create a new permission set (IAM policy) on the next page.

![Create permission set](/images/posts/1/014-aws-permission-set.PNG)

![Create permission set](/images/posts/1/015-aws-custom-permissions-set.PNG)

The permissions policy will be an IAM policy that will grant the ability to assume role(s). It's advisable to not allow users to directly assume a managed policy as they have had the history of being over-privileged (see [Scott Piper](https://summitroute.com/)). Additionally, the permissions assigned to such policies can shift under your feet as they are modified by AWS. Instead, create your own role that you have the ability modify through code. Even if it starts as only a proxy for the managed policy, if you need to change permissions across accounts or resources in the future, you will only need to change them in specific roles.

![Elevated role](/images/posts/1/016-aws-assume-elevated-role-edited.png)

**Ensure that the role to which you're granting access has a trust policy allowing both your IdP and your AWS account root the ability to access**

![trust](/images/posts/1/026-aws-trust-relationship-role-edited.png)

After creating the permission set, go back to AWS SSO and assign it to the group.

![Assign permission set to group](/images/posts/1/017-aws-select-permission-set-edited.png)

![Verify permission set](/images/posts/1/018-aws-verify-permission-set-edited.png)

In a terminal window, run the command `aws configure sso`. You should be presented with a prompt with a URL and a temporary code. Navigating to the URL should force you to authenticate to your IdP.

![verify](/images/posts/1/019-aws-configure-cli-edited.png)

![verify](/images/posts/1/021-aws-redirect-to-idp-edited.png)

Following that, you will be redirected to an AWS page so that you can verify the request with the code given.

![verify](/images/posts/1/020-aws-verify-request.PNG)



![verify](/images/posts/1/023-aws-success.PNG)

After verifying, you should receive a message like:

![verify](/images/posts/1/024-aws-cli-credentials-edited.png)

Now, you can use the AWS CLI with your SSO profile!

![use cli](/images/posts/1/call-aws-api-edited.PNG)

To get credentials you can use with Terraform, you can assume a role to get a temporary keypair, and then export those credentials as environmental variables.

```bash
$ aws sts assume-role --role-arn <role arn> --role-session-name <pick your own>
{
	"Credentials": {
		"AccessKeyId": "xxx",
		"SecretAccessKey": "xxx",
		"SessionToken": "xxx",
		"Expiration": "xxx"
	},
	"AssumedRoleUser": {
		"AssumedRoleId": "xxx",
		"Arn": "xxx"
	}
}
```

With the access keypair, you can then export environmental variables as follows:

```
export AWS_ACCESS_KEY_ID="xxx"
export AWS_SECRET_ACCESS_KEY="xxx"
```



When this keypair or your SSO session expires, you may start to receive error messages.

![error](/images/posts/1/027-aws-expired-token.PNG)



To fix this, you'll need to log in once again over the command line as follows:

![login](/images/posts/1/028-aws-login-cli-edited.PNG)



With all this in place, you should now be able to utilize your CLI, scripts, or Terraform that depend on AWS credentials!